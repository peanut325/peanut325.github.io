

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/bg/dog.png">
  <link rel="icon" href="/img/bg/dog.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="peanut">
  <meta name="keywords" content="">
  
    <meta name="description" content="Redis概述和安装概述 Redis是一个开源的key-value存储系统。 和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。 这些数据类型都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。 在此基础上">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://example.com/2022/02/03/redis6/index.html">
<meta property="og:site_name" content="peanut&#39; blog">
<meta property="og:description" content="Redis概述和安装概述 Redis是一个开源的key-value存储系统。 和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。 这些数据类型都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。 在此基础上">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/bg/redislogo.jpg">
<meta property="article:published_time" content="2022-02-03T03:35:00.000Z">
<meta property="article:modified_time" content="2022-02-10T12:17:01.207Z">
<meta property="article:author" content="peanut">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/bg/redislogo.jpg">
  
  
  <title>Redis - peanut&#39; blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":"flase"},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 100vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>peanut325</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bg/redisback.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Redis">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-02-03 11:35" pubdate>
        2022年2月3日 中午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      22k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      184 分钟
    </span>
  

  
  
</div>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="iconfont icon-arrowdown"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Redis</h1>
            
            <div class="markdown-body">
              <h1 id="Redis概述和安装"><a href="#Redis概述和安装" class="headerlink" title="Redis概述和安装"></a>Redis概述和安装</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Redis是一个开源的<strong>key-value</strong>存储系统。</li>
<li>和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。</li>
<li>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</li>
<li>在此基础上，Redis支持各种不同方式的排序。</li>
<li>与memcached一样，为了保证效率，数据都是缓存在内存中。</li>
<li>区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</li>
<li>并且在此基础上实现了master-slave(主从)同步。</li>
</ul>
<p>相关知识：</p>
<ul>
<li>Redis是<strong>单线程+多路IO复用技术</strong>，与Memcache三点不同: <strong>支持多数据类型，支持持久化，单线程+多路IO复用</strong></li>
<li>Redis默认端口为<strong>6379</strong></li>
<li>默认<strong>16个数据库</strong>，类似数组下标从0开始，初始默认使用0号库（使用select可以换库）</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>此处Redis是在Linux上安装， 不用考虑在windows环境下对Redis的支持</p>
<ol>
<li><p>先下载Redis安装包</p>
</li>
<li><p>使用Xftp文件传输工具将压缩包传输到Linux的opt目录</p>
<p><img src="/img/redis6.assets/image-20220123112438172.png" alt="image-20220123112438172"></p>
<p>在Xshell上使用命令查看是否传输成功</p>
<p><img src="/img/redis6.assets/image-20220123112555011.png" alt="image-20220123112555011"></p>
</li>
<li><p>Redis需要gcc编译环境的支持</p>
<ul>
<li>使用<strong>gcc –version</strong> 命令查看是否安装gcc （此时我的gcc版本为4.8.5）</li>
<li>使用<strong>yum install gcc</strong> 命令安装（需要联网，安装过程注意输入y）</li>
</ul>
</li>
<li><p>解压Redis压缩文件</p>
<ul>
<li>使用<strong>tar -zxvf</strong> redis-6.2.6.tar.gz 解压</li>
</ul>
</li>
<li><p>编译Redis</p>
<ul>
<li><p>cd进入解压后的redis目录，使用<strong>make</strong>编译</p>
<p><img src="/img/redis6.assets/image-20220123113745704.png" alt="image-20220123113745704"></p>
</li>
</ul>
</li>
<li><p>安装Redis</p>
<ul>
<li><p>cd进入目录使用<strong>make install</strong> 安装</p>
<p><img src="/img/redis6.assets/image-20220123113913711.png" alt="image-20220123113913711"></p>
</li>
</ul>
</li>
<li><p>检查是否安装成功</p>
<ul>
<li><p>使用<strong>cd /usr/local/bin</strong>进入到目录查看即可</p>
<p><img src="/img/redis6.assets/image-20220123114339633.png" alt="image-20220123114339633"></p>
</li>
</ul>
</li>
</ol>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><ul>
<li><p>前台启动</p>
<p>进入cd /usr/local/bin 目录使用<strong>redis-server</strong>命令可以直接启动，弊端是Xshell关闭连接后，redis也会关闭</p>
</li>
<li><p>后台启动（推荐）</p>
<ol>
<li><p>进入cd /usr/local/bin 目录找到redis.conf配置文件，使用命令<strong>cp redis.conf /etc/redis.conf</strong>将他复制到etc目录</p>
</li>
<li><p>进入etc目录修改**/etc目录下的redis.conf<strong>文件，注意将</strong>daemonize no改成daemonize yes**</p>
<p>使用<strong>vi redis.conf</strong>命令进行修改，/daemonize命令找到位置，按 <strong>i</strong> 进行修改后，<strong>Esc</strong> 按键退出修改，**:wq!**保存即可</p>
</li>
<li><p>进入cd /usr/local/bin </p>
<ul>
<li>使用 <strong>redis-server /etc/redis.conf</strong> 命令开启redis，此时查询进程状态即可<strong>ps -ef | grep redis</strong></li>
<li>或者使用客户端访问 即<strong>redis-cli</strong> [-p 端口号] 命令也可以</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><ul>
<li><strong>redis-cli shutdown</strong> 单实例关闭</li>
<li><strong>shutdown</strong> 在终端中关闭 </li>
<li>ps ef | grep redis 查询进程后，直接 <strong>kill [-9] 进程号</strong> 来关闭</li>
</ul>
<h1 id="常用五大数据类型"><a href="#常用五大数据类型" class="headerlink" title="常用五大数据类型"></a>常用五大数据类型</h1><p>redis命令：<a target="_blank" rel="noopener" href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p>
<h2 id="Redis键（key）"><a href="#Redis键（key）" class="headerlink" title="Redis键（key）"></a>Redis键（key）</h2><ul>
<li>keys *查看当前库所有key   (匹配：keys *1)</li>
<li>set key value 创建key</li>
<li>exists key判断某个key是否存在</li>
<li>type key 查看你的key是什么类型</li>
<li>del key    删除指定的key数据</li>
<li>unlink key  根据value选择非阻塞删除</li>
<li>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</li>
<li>expire key 10  10秒钟：为给定的key设置过期时间</li>
<li>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</li>
<li>select命令切换数据库</li>
<li>dbsize查看当前数据库的key的数量</li>
<li>flushdb清空当前库（谨慎使用）</li>
<li>flushall通杀全部库（谨慎使用）</li>
</ul>
<h2 id="Redis字符串（string）"><a href="#Redis字符串（string）" class="headerlink" title="Redis字符串（string）"></a>Redis字符串（string）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，<strong>一个key对应一个value。</strong></li>
<li>String类型<strong>是二进制安全的</strong>。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</li>
<li>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是<strong>512M</strong></li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以<strong>修改的字符串</strong>，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</p>
<p><img src="/img/redis6.assets/wpsE542.tmp.jpg" alt="img"> </p>
<p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><p>set  <key><value>添加键值对</p>
</li>
<li><p>get  <key>查询对应键值</p>
</li>
<li><p>append  <key><value>将给定的<value> 追加到原值的末尾</p>
</li>
<li><p>strlen  <key>获得值的长度</p>
</li>
<li><p>setnx  <key><value>只有在 <strong>key 不存在时</strong>   设置 key 的值</p>
</li>
<li><p>incr  <key> 将 key 中储存的数字值增1，只能对数字值操作，如果为空，新增值为1</p>
</li>
<li><p>decr  <key>将 key 中储存的数字值减1，只能对数字值操作，如果为空，新增值为-1</p>
</li>
<li><p>incrby / decrby  <key>&lt;步长&gt;将 key 中储存的数字值增减。自定义步长。</p>
</li>
</ul>
<p>incr命令满足原子性</p>
<p>所谓原子操作是指<strong>不会被线程调度机制打断的操作</strong>；</p>
<p>这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。</p>
<p>（1）在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</p>
<p>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</p>
<p>Redis单命令的原子性主要得益于Redis的单线程。</p>
<ul>
<li>mset  <key1><value1><key2><value2>  …..  同时设置一个或多个 key-value对  </li>
<li>mget  <key1><key2><key3> ….. 同时获取一个或多个 value  </li>
<li>msetnx <key1><value1><key2><value2>  ….. 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在（原子性，有一个失败则都失败）</li>
<li>getrange  <key>&lt;起始位置&gt;&lt;结束位置&gt;  获得值的范围，类似java中的substring</li>
<li>setrange  <key>&lt;起始位置&gt;<value>  用 <value>  覆写<key>所储存的字符串值，从&lt;起始位置&gt;开始(<strong>索引从0开始</strong>)。</li>
<li>setex  <key>&lt;过期时间&gt;<value>  设置键值的同时，设置过期时间，单位秒。</li>
<li>getset <key><value>  以新换旧，设置了新值同时获得旧值。</li>
</ul>
<h2 id="Redis列表（List）"><a href="#Redis列表（List）" class="headerlink" title="Redis列表（List）"></a>Redis列表（List）</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>单键多值</p>
<p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。插入和删除效率高，但查找效率较低。</p>
<p><img src="/img/redis6.assets/wpsA3A1.tmp.png" alt="img"></p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>List的数据结构为快速链表<strong>quickList</strong>。</p>
<p>首先在列表元素较少的情况下会使用<strong>一块连续的内存存储</strong>，这个结构是<strong>ziplist</strong>，也即是压缩列表。</p>
<p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p>
<p>当数据量比较多的时候才会改成quicklist。</p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p>
<p><img src="/img/redis6.assets/wpsB06F.tmp.jpg" alt="img"> </p>
<p>Redis将<strong>链表和ziplist结合起来组成了quicklist</strong>。也就是将<strong>多个ziplist使用双向指针串起来使用</strong>。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>lpush/rpush  <key><value1><value2><value3> ….  从左边/右边插入一个或多个值。</li>
<li>lpop/rpop  <key> 从左边/右边吐出一个值。值在键在，值光键亡。 </li>
<li>rpoplpush  <key1><key2> 从<key1>列表右边吐出一个值，插到<key2>列表左边。</li>
<li>lrange <key><start><stop> 按照索引下标获得元素(从左到右)</li>
<li>lrange mylist 0 -1  0左边第一个，-1右边第一个，（0-1表示获取所有）</li>
<li>lindex <key><index>按照索引下标获得元素(从左到右)</li>
<li>llen <key>获得列表长度 </li>
<li>linsert <key>  before <value><newvalue>在<value>的后面插入<newvalue>插入值</li>
<li>lrem <key><n><value>从左边删除n个lse(从左到右)</li>
<li>lset<key><index><value>将列表key下标为index的值替换成value</li>
</ul>
<h2 id="Redis集合（Set）"><a href="#Redis集合（Set）" class="headerlink" title="Redis集合（Set）"></a>Redis集合（Set）</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>Redis的Set是<strong>string类型的无序集合</strong>。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是**O(1)**。</p>
<p>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><p>Set数据结构是dict字典，字典是用<strong>哈希表</strong>实现的。</p>
<p>Java中HashSet的内部实现使用的是<strong>HashMap</strong>，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部<strong>也使用hash结构</strong>，所有的value都指向同一个内部值。</p>
<h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>sadd <key><value1><value2> …..  将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</li>
<li>smembers <key> 取出该集合的所有值。</li>
<li>sismember <key><value> 判断集合<key>是否为含有该<value>值，有1，没有0</li>
<li>scard<key> 返回该集合的元素个数。</li>
<li>srem <key><value1><value2> ….  删除集合中的某个元素。</li>
<li>spop <key> <strong>随机</strong>从该集合中吐出一个值。</li>
<li>srandmember <key><n> 随机从该集合中取出n个值。不会从集合中删除 。</li>
<li>smove <source><destination> value把集合中一个值从一个集合移动到另一个集合</li>
<li>sinter <key1><key2> 返回两个集合的交集元素。</li>
<li>sunion <key1><key2> 返回两个集合的并集元素。</li>
<li>sdiff <key1><key2> 返回两个集合的<strong>差集</strong>元素(key1中的，不包含key2中的)</li>
</ul>
<h2 id="Redis哈希（Hash）"><a href="#Redis哈希（Hash）" class="headerlink" title="Redis哈希（Hash）"></a>Redis哈希（Hash）</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>Redis hash 是一个<strong>键值对集合</strong>。</p>
<p>Redis hash是一个string类型的<strong>field和value的映射表</strong>，hash特别适合用于存储对象。类似Java里面的**Map&lt;String,Object&gt;**。</p>
<h3 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h3><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p>
<h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>hset <key><field><value> 给<key>集合中的  <field>键赋值<value></li>
<li>hget <key1><field>从<key1> 集合<field>取出 value </li>
<li>hmset <key1><field1><value1><field2><value2>…  批量设置hash的值</li>
<li>hexists<key1><field> 查看哈希表 key 中，给定域 field 是否存在。 </li>
<li>hkeys <key> 列出该hash集合的所有field</li>
<li>hvals <key> 列出该hash集合的所有value</li>
<li>hincrby <key><field><increment> 为哈希表 key 中的域 field 的值加上增量 1  -1</li>
<li>hsetnx <key><field><value> 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 </li>
</ul>
<h2 id="Redis有序集合（Zset）"><a href="#Redis有序集合（Zset）" class="headerlink" title="Redis有序集合（Zset）"></a>Redis有序集合（Zset）</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>Redis有序集合zset与普通集合set非常相似，是一个<strong>没有重复元素的字符串</strong>集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个<strong>评分（score）</strong>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，<strong>但是评分可以是重复了</strong> 。</p>
<p>因为元素是<strong>有序</strong>的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p>
<p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
<h3 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h3><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>zset底层使用了两个数据结构</p>
<p>（1）<strong>hash</strong>，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</p>
<p>（2）<strong>跳跃表</strong>，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。加快查找效率。</p>
<h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>zadd  <key><score1><value1><score2><value2>…  将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</li>
<li>zrange <key><start><stop>  [WITHSCORES]  返回有序集 key 中，下标在<start><stop>之间的元素，带WITHSCORES，可以让分数一起和值返回到结果集。</li>
<li>zrangebyscore key min max [withscores] [limit offset count]    返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 </li>
<li>zrevrangebyscore key max min [withscores] [limit offset count] 同上，改为从大到小排列。 </li>
<li>zincrby <key><increment><value> 为元素的score加上增量</li>
<li>zrem  <key><value> 删除该集合下，指定值的元素 </li>
<li>zcount <key><min><max> 统计该集合，分数区间内的元素个数 </li>
<li>zrank <key><value> 返回该值在集合中的排名，从0开始。</li>
</ul>
<h1 id="Redis的配置文件"><a href="#Redis的配置文件" class="headerlink" title="Redis的配置文件"></a>Redis的配置文件</h1><h2 id="Units单位"><a href="#Units单位" class="headerlink" title="Units单位"></a>Units单位</h2><p>配置大小单位,开头定义了一些基本的度量单位，只支持<strong>bytes</strong>，不支持bit，大小写不敏感</p>
<h2 id="INCLUDES包含"><a href="#INCLUDES包含" class="headerlink" title="INCLUDES包含"></a>INCLUDES包含</h2><p>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来</p>
<h2 id="网络相关配置"><a href="#网络相关配置" class="headerlink" title="网络相关配置"></a>网络相关配置</h2><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>默认情况bind=127.0.0.1<strong>只能接受本机的访问请求</strong>，不写的情况下，无限制接受任何ip地址的访问</p>
<p>生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要<strong>将其注释掉</strong></p>
<p>如果开启了<strong>protected-mode</strong>，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应</p>
<p><img src="/img/redis6.assets/image-20220123165829199.png" alt="image-20220123165829199"></p>
<p>重启redis后，查看进程，此时不是本机访问</p>
<p><img src="/img/redis6.assets/image-20220123171701177.png" alt="image-20220123171701177"></p>
<h3 id="protected-mode"><a href="#protected-mode" class="headerlink" title="protected-mode"></a>protected-mode</h3><p>将本机访问保护模式设置<strong>no</strong></p>
<p><img src="/img/redis6.assets/image-20220123170109109.png" alt="image-20220123170109109"></p>
<h3 id="port端口号"><a href="#port端口号" class="headerlink" title="port端口号"></a>port端口号</h3><p>默认为6379</p>
<h3 id="tcp-backlog"><a href="#tcp-backlog" class="headerlink" title="tcp-backlog"></a>tcp-backlog</h3><p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。</p>
<p>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。</p>
<p>注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果</p>
<h3 id="time-out"><a href="#time-out" class="headerlink" title="time-out"></a>time-out</h3><p>一个空闲的客户端维持多少秒会关闭，<strong>0表示关闭该功能。即永不关闭</strong>。</p>
<h3 id="tcp-keepalive"><a href="#tcp-keepalive" class="headerlink" title="tcp-keepalive"></a>tcp-keepalive</h3><p>对访问客户端的一种心跳检测，每个n秒检测一次。</p>
<p>单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60 </p>
<h2 id="GENERAL通用"><a href="#GENERAL通用" class="headerlink" title="GENERAL通用"></a>GENERAL通用</h2><h3 id="daemonize"><a href="#daemonize" class="headerlink" title="daemonize"></a>daemonize</h3><p>是否为后台进程，设置为yes</p>
<p>守护进程，后台启动</p>
<p><img src="/img/redis6.assets/wpsCF.tmp.png" alt="img"> </p>
<h3 id="pidfile"><a href="#pidfile" class="headerlink" title="pidfile"></a>pidfile</h3><p>存放pid文件的位置，每个实例会产生一个不同的pid文件</p>
<p><img src="/img/redis6.assets/wpsD0.tmp.png" alt="img"> </p>
<p><em><strong>*loglevel*</strong></em> </p>
<p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为<em><strong>*notice*</strong></em></p>
<p>四个级别根据使用阶段来选择，生产环境选择notice 或者warning</p>
<p><img src="/img/redis6.assets/wpsD1.tmp.png" alt="img"> </p>
<p><em><strong>*logfile*</strong></em> </p>
<p>日志文件名称</p>
<p><img src="/img/redis6.assets/wpsE2.tmp.png" alt="img"> </p>
<p><em><strong>*d*</strong></em><em><strong>*atabases 16*</strong></em> </p>
<p>设定库的数量 默认16，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id</p>
<h1 id="发布和订阅"><a href="#发布和订阅" class="headerlink" title="发布和订阅"></a>发布和订阅</h1><p>Redis 发布订阅 (pub/sub) 是一种<strong>消息通信模式</strong>：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
<p>Redis 客户端<strong>可以订阅任意数量的频道</strong>。</p>
<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现:"></a>简单实现:</h2><ol>
<li> 打开一个客户端订阅channel1</li>
</ol>
<p>   SUBSCRIBE channel1</p>
<ol start="2">
<li><p>打开另一个客户端，给channel1发布消息hello</p>
<p>publish channel1 hello</p>
<p><img src="/img/redis6.assets/wps1CB9.tmp.jpg" alt="img"> </p>
<p>返回的1是订阅者数量</p>
</li>
<li><p>打开第一个客户端可以看到发送的消息</p>
</li>
</ol>
<h1 id="Redis新数据类型"><a href="#Redis新数据类型" class="headerlink" title="Redis新数据类型"></a>Redis新数据类型</h1><h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图</p>
<p><img src="/img/redis6.assets/wpsB45B.tmp.jpg" alt="img"> </p>
<p>合理地使用操作位能够有效地提高内存使用率和开发效率。</p>
<p>​    Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p>
<p>（1） Bitmaps<strong>本身不是一种数据类型</strong>， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</p>
<p>（2） Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</p>
<p><img src="/img/redis6.assets/wpsB45C.tmp.jpg" alt="img"> </p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="setbit"><a href="#setbit" class="headerlink" title="setbit"></a>setbit</h4><p>（1）格式</p>
<p>setbit<key><offset><value> 设置Bitmaps中某个偏移量的值（0或1）</p>
<p>*offset:偏移量从0开始</p>
<p>（2）实例</p>
<p>每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。</p>
<p>设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，userid=1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图</p>
<p><img src="/img/redis6.assets/wpsB45E.tmp.jpg" alt="img"> </p>
<p>unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps</p>
<p><img src="/img/redis6.assets/wpsB45F.tmp.jpg" alt="img"> </p>
<p>注：</p>
<p>很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。</p>
<p>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。</p>
<h4 id="getbit"><a href="#getbit" class="headerlink" title="getbit"></a>getbit</h4><p>（1）格式</p>
<p>getbit<key><offset>获取Bitmaps中某个偏移量的值</p>
<p><img src="/img/redis6.assets/wpsB460.tmp.jpg" alt="img"> </p>
<p>获取键的第offset位的值（从0开始算）</p>
<p>（2）实例</p>
<p>获取id=8的用户是否在2020-11-06这天访问过， 返回0说明没有访问过：</p>
<p><img src="/img/redis6.assets/wpsB461.tmp.jpg" alt="img"> </p>
<p>注：因为100根本不存在，所以也是返回0</p>
<h4 id="bitcount"><a href="#bitcount" class="headerlink" title="bitcount"></a>bitcount</h4><p>统计****字符串****被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。</p>
<p>（1）格式</p>
<p>bitcount<key>[start end] 统计字符串从start字节到end字节比特值为1的数量</p>
<p><img src="/img/redis6.assets/wpsB462.tmp.jpg" alt="img"> </p>
<p>（2）实例</p>
<p>计算2022-11-06这天的独立访问用户数量</p>
<p><img src="/img/redis6.assets/wpsB463.tmp.jpg" alt="img"> </p>
<p>个字节之间的独立访问用户数， 对应的用户id是11， 15， 19。</p>
<p>start和end代表    起始和结束字节数， 下面操作计算用户id在第1个字节到第3<img src="/img/redis6.assets/wpsB473.tmp.jpg" alt="img"></p>
<p>举例： K1 【01000001 01000000  00000000 00100001】，对应【0，1，2，3】</p>
<p>bitcount K1 1 2  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000</p>
<p>–》bitcount K1 1 2 　　–》1</p>
<p>bitcount K1 1 3  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000 00100001</p>
<p>–》bitcount K1 1 3　　–》3</p>
<p>bitcount K1 0 -2  ： 统计下标0到下标倒数第2，字节组中bit=1的个数，即01000001  01000000  00000000</p>
<p>–》bitcount K1 0 -2　　–》3</p>
<p> 注意：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。</p>
<h4 id="bitop"><a href="#bitop" class="headerlink" title="bitop"></a>bitop</h4><p>(1)格式</p>
<p>bitop and(or/not/xor) <destkey> [key…]</p>
<p><img src="/img/redis6.assets/wpsB474.tmp.jpg" alt="img"> </p>
<p>bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。</p>
<p>(2)实例</p>
<p>2020-11-04 日访问网站的userid=1,2,5,9。</p>
<p>setbit unique:users:20201104 1 1</p>
<p>setbit unique:users:20201104 2 1</p>
<p>setbit unique:users:20201104 5 1</p>
<p>setbit unique:users:20201104 9 1</p>
<p>2020-11-03 日访问网站的userid=0,1,4,9。</p>
<p>setbit unique:users:20201103 0 1</p>
<p>setbit unique:users:20201103 1 1</p>
<p>setbit unique:users:20201103 4 1</p>
<p>setbit unique:users:20201103 9 1</p>
<p>计算出两天都访问过网站的用户数量</p>
<p>bitop and unique:users:and:20201104_03</p>
<p> unique:users:20201103unique:users:20201104</p>
<p><img src="/img/redis6.assets/wpsB475.tmp.jpg" alt="img"> </p>
<p><img src="/img/redis6.assets/wpsB476.tmp.jpg" alt="img"> </p>
<p>计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集</p>
<p><img src="/img/redis6.assets/wpsB477.tmp.jpg" alt="img"> </p>
<h3 id="Bitmaps与set对比"><a href="#Bitmaps与set对比" class="headerlink" title="Bitmaps与set对比"></a>Bitmaps与set对比</h3><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表</p>
<table>
<thead>
<tr>
<th>set和Bitmaps存储一天活跃用户对比</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>每个用户id占用空间</td>
<td>需要存储的用户量</td>
<td>全部内存量</td>
</tr>
<tr>
<td>集合类型</td>
<td>64位</td>
<td>50000000</td>
<td>64位*50000000 = 400MB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>1位</td>
<td>100000000</td>
<td>1位*100000000 = 12.5MB</td>
</tr>
</tbody></table>
<p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的</p>
<table>
<thead>
<tr>
<th>set和Bitmaps存储独立用户空间对比</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>一天</td>
<td>一个月</td>
<td>一年</td>
</tr>
<tr>
<td>集合类型</td>
<td>400MB</td>
<td>12GB</td>
<td>144GB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>12.5MB</td>
<td>375MB</td>
<td>4.5GB</td>
</tr>
</tbody></table>
<p>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。</p>
<table>
<thead>
<tr>
<th>set和Bitmaps存储一天活跃用户对比（独立用户比较少）</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>每个userid占用空间</td>
<td>需要存储的用户量</td>
<td>全部内存量</td>
</tr>
<tr>
<td>集合类型</td>
<td>64位</td>
<td>100000</td>
<td>64位*100000 = 800KB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>1位</td>
<td>100000000</td>
<td>1位*100000000 = 12.5MB</td>
</tr>
</tbody></table>
<h2 id="HaperLogLog"><a href="#HaperLogLog" class="headerlink" title="HaperLogLog"></a>HaperLogLog</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。</p>
<p>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p>
<p>解决基数问题有很多种方案：</p>
<p>（1）数据存储在MySQL表中，使用distinct count计算不重复个数</p>
<p>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p>
<p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p>
<p>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog</p>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p>什么是基数?</p>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
<h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><h4 id="pfadd"><a href="#pfadd" class="headerlink" title="pfadd"></a>pfadd</h4><p>（1）格式</p>
<p>pfadd <key>&lt; element&gt; [element …]  添加指定元素到 HyperLogLog 中</p>
<p>（2）实例</p>
<p><img src="/img/redis6.assets/wpsF4A0.tmp.jpg" alt="img"> </p>
<p>​    将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。</p>
<h4 id="pfcount"><a href="#pfcount" class="headerlink" title="pfcount"></a>pfcount</h4><p>（1）格式</p>
<p>pfcount<key> [key …] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可</p>
<p>（2）实例</p>
<p><img src="/img/redis6.assets/wpsF4B2.tmp.jpg" alt="img"> </p>
<h4 id="pfmerg"><a href="#pfmerg" class="headerlink" title="pfmerg"></a>pfmerg</h4><p>（1）格式</p>
<p>pfmerge<destkey><sourcekey> [sourcekey …]  将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</p>
<p>（2）实例</p>
<p><img src="/img/redis6.assets/wpsF4B4.tmp.jpg" alt="img"> </p>
<h2 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h2><h3 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h3><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p>
<h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><h4 id="geoadd"><a href="#geoadd" class="headerlink" title="geoadd"></a>geoadd</h4><p>（1）格式</p>
<p>geoadd<key>&lt; longitude&gt;<latitude><member> [longitude latitude member…]   添加地理位置（经度，纬度，名称）</p>
<p>（2）实例</p>
<p>geoadd china:city 121.47 31.23 shanghai</p>
<p>geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing</p>
<p><img src="/img/redis6.assets/wpsCCB5.tmp.jpg" alt="img"> </p>
<p>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。</p>
<p>有效的经度从 <strong>-180 度到 180 度</strong>。有效的纬度从 -85.05112878 度到 85.05112878 度。当坐标位置超出指定范围时，该命令将会返回一个错误。</p>
<p><strong>已经添加的数据，是无法再次往里面添加的</strong>。</p>
<h4 id="geopos"><a href="#geopos" class="headerlink" title="geopos"></a>geopos</h4><p>（1）格式</p>
<p>geopos  <key><member> [member…]  获得指定地区的坐标值 </p>
<p>（2）实例</p>
<p><img src="/img/redis6.assets/wps3E14.tmp.jpg" alt="img"> </p>
<h4 id="geodist"><a href="#geodist" class="headerlink" title="geodist"></a>geodist</h4><p>（1）格式</p>
<p>geodist<key><member1><member2>  [m|km|ft|mi ]  获取两个位置之间的直线距离 </p>
<p>（2）实例</p>
<p>获取两个位置之间的直线距离</p>
<p><img src="/img/redis6.assets/wps3E16.tmp.jpg" alt="img"> </p>
<p>单位：</p>
<p>m 表示单位为米[默认值]。</p>
<p>km 表示单位为千米。</p>
<p>mi 表示单位为英里。</p>
<p>ft 表示单位为英尺。</p>
<p>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</p>
<h4 id="georadius"><a href="#georadius" class="headerlink" title="georadius"></a>georadius</h4><p>（1）格式</p>
<p>georadius<key>&lt; longitude&gt;<latitude>radius m|km|ft|mi  以给定的经纬度为中心，找出某一半径内的元素 </p>
<p>经度 纬度 距离 单位</p>
<p>（2）实例</p>
<p><img src="/img/redis6.assets/image-20220123195937358.png" alt="image-20220123195937358"></p>
<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><h2 id="Jedis需要的依赖"><a href="#Jedis需要的依赖" class="headerlink" title="Jedis需要的依赖"></a>Jedis需要的依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>连接时注意：</p>
<ul>
<li><p>禁用Linux的防火墙：Linux(CentOS7)里执行命令  <strong>systemctl stop/disable firewalld.service</strong>，此时可以查看防火墙状态 <strong>systemctl status firewalld.service</strong>  或者开启6379端口 <strong>firewall-cmd –zone=public –add-port=6379/tcp –permanent</strong> ，修改完成后重启防火墙<strong>firewall-cmd –reload</strong>  </p>
</li>
<li><p>redis.conf中注释掉bind 127.0.0.1 ,然后 protected-mode no</p>
</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.jedis;<br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;192.168.137.3&quot;</span>,<span class="hljs-number">6379</span>);<br>String pong = jedis.ping();<br>System.out.println(<span class="hljs-string">&quot;连接成功：&quot;</span>+pong);<br>jedis.close();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>具体可以查找Jedis的API</p>
<h1 id="Redis事务和锁机制"><a href="#Redis事务和锁机制" class="headerlink" title="Redis事务和锁机制"></a>Redis事务和锁机制</h1><h2 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h2><p>Redis事务是一个<strong>单独的隔离操作</strong>：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>Redis事务的主要作用就是<strong>串联多个命令防止别的命令插队</strong>。</p>
<h2 id="Multi、Exec、discard"><a href="#Multi、Exec、discard" class="headerlink" title="Multi、Exec、discard"></a>Multi、Exec、discard</h2><p>从输入Multi命令开始，输入的命令都会<strong>依次进入命令队列中</strong>，但不会<strong>执行</strong>，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。</p>
<p>组队的过程中可以通过<strong>discard</strong>来放弃组队。  </p>
<p><img src="/img/redis6.assets/image-20220124091541482.png" alt="image-20220124091541482"></p>
<h2 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h2><ul>
<li>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</li>
</ul>
<p><img src="/img/redis6.assets/image-20220124092218705.png" alt="image-20220124092218705"></p>
<p><img src="/img/redis6.assets/image-20220124092158560.png" alt="image-20220124092158560"></p>
<ul>
<li>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</li>
</ul>
<p><img src="/img/redis6.assets/image-20220124092310947.png" alt="image-20220124092310947"></p>
<h2 id="事务冲突和解决"><a href="#事务冲突和解决" class="headerlink" title="事务冲突和解决"></a>事务冲突和解决</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>一个请求想给金额减8000</p>
<p>一个请求想给金额减5000</p>
<p>一个请求想给金额减1000</p>
<p><img src="/img/redis6.assets/image-20220124092539065.png" alt="image-20220124092539065"></p>
<p>可能会造成账户为负值</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候<strong>都会上锁</strong>，这样别人想拿这个数据就会block直到它拿到锁。传统的<strong>关系型数据库里边就用到了很多这种锁机制</strong>，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<p><img src="/img/redis6.assets/image-20220124092817647.png" alt="image-20220124092817647"></p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以<strong>使用版本号</strong>等机制。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种<strong>check-and-set机制实现事务的</strong>。</p>
<h3 id="WATCH-key-key-…"><a href="#WATCH-key-key-…" class="headerlink" title="WATCH key [key …]"></a>WATCH key [key …]</h3><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) <strong>key 被其他命令所改动，那么事务将被打断</strong></p>
<ul>
<li><p>2个终端同时操作实例</p>
<p><img src="/img/redis6.assets/image-20220124094440842.png" alt="image-20220124094440842"></p>
<p><img src="/img/redis6.assets/image-20220124094412731.png" alt="image-20220124094412731"></p>
<p>因为修改了版本，会造成提交无法执行 </p>
</li>
</ul>
<h3 id="unwatch"><a href="#unwatch" class="headerlink" title="unwatch"></a>unwatch</h3><p>取消 WATCH 命令对所有 key 的监视。</p>
<p>如果在执行 WATCH 命令之后 ，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。</p>
<h2 id="Redis事务三大特性"><a href="#Redis事务三大特性" class="headerlink" title="Redis事务三大特性"></a>Redis事务三大特性</h2><ul>
<li><p>单独的隔离操作 ：事务中的所有命令都<strong>会序列化、按顺序地执行</strong>。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </p>
</li>
<li><p>没有隔离级别的概念 ：队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</p>
</li>
<li><p>不保证原子性 ：事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有<strong>回滚</strong> </p>
</li>
</ul>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="RDB（Redis-Database）"><a href="#RDB（Redis-Database）" class="headerlink" title="RDB（Redis Database）"></a>RDB（Redis Database）</h2><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>
<h3 id="备份是怎么执行的"><a href="#备份是怎么执行的" class="headerlink" title="备份是怎么执行的"></a>备份是怎么执行的</h3><p>Redis会单独创建（<strong>fork</strong>）一个子进程来进行持久化，会先将数据写入到 <strong>一个临时文件</strong>中，待持久化过程都结束了，再用这个<strong>临时文件替换上次持久化好的文件</strong>。 整个过程中，<strong>主进程是不进行任何IO操作的</strong>，这就确保了极高的<strong>性能</strong> 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是<strong>最后一次持久化后的数据可能丢失</strong>。</p>
<h3 id="FORK"><a href="#FORK" class="headerlink" title="FORK"></a>FORK</h3><ul>
<li> Fork的作用是<strong>复制一个与当前进程一样的进程</strong>。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为<strong>原进程的子进程</strong></li>
<li>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了<strong>写时复制技术</strong></li>
<li>一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</li>
</ul>
<h3 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h3><p><img src="/img/redis6.assets/image-20220124140258868.png" alt="image-20220124140258868"></p>
<h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><h4 id="dump-rdb文件"><a href="#dump-rdb文件" class="headerlink" title="dump.rdb文件"></a>dump.rdb文件</h4><p>在redis.conf中配置文件名称，默认为dump.rdb</p>
<p><img src="/img/redis6.assets/wpsF3B3.tmp.jpg" alt="img"> </p>
<p>配置位置</p>
<p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下</p>
<p>dir “/myredis/“</p>
<p><img src="/img/redis6.assets/wpsF3B4.tmp.jpg" alt="img"> </p>
<h4 id="如何触发RDB快照；保持策略"><a href="#如何触发RDB快照；保持策略" class="headerlink" title="如何触发RDB快照；保持策略"></a>如何触发RDB快照；保持策略</h4><p>配置文件中默认的快照配置</p>
<p><img src="/img/redis6.assets/wpsF3C5.tmp.jpg" alt="img"> </p>
<p>命令  save  VS  bgsave</p>
<p>save ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。</p>
<p>bgsave：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。</p>
<p>可以通过lastsave 命令获取最后一次成功执行快照的时间</p>
<h4 id="flushall-命令"><a href="#flushall-命令" class="headerlink" title="flushall  命令"></a>flushall  命令</h4><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p>
<h4 id="SNAPSHOTTING-快照"><a href="#SNAPSHOTTING-快照" class="headerlink" title="SNAPSHOTTING  快照"></a>SNAPSHOTTING  快照</h4><h5 id="Save"><a href="#Save" class="headerlink" title="Save"></a>Save</h5><p>格式：save 秒钟 写操作次数</p>
<p>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，</p>
<p>默认是1分钟内改了\万次，或5分钟内改了10次，或15分钟内改了次。</p>
<p>禁用</p>
<p>不设置save指令，或者给save传入空字符串</p>
<p>stop-writes-on-bgsave-error</p>
<p><img src="/img/redis6.assets/wpsF3C6.tmp.jpg" alt="img"> </p>
<p>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.</p>
<h5 id="rdbcompression-压缩文件"><a href="#rdbcompression-压缩文件" class="headerlink" title="rdbcompression  压缩文件"></a>rdbcompression  压缩文件</h5><p><img src="/img/redis6.assets/wpsF3C7.tmp.jpg" alt="img"> </p>
<p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。</p>
<p>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</p>
<h5 id="rdbchecksum-检查完整性"><a href="#rdbchecksum-检查完整性" class="headerlink" title="rdbchecksum  检查完整性"></a>rdbchecksum  检查完整性</h5><p><img src="/img/redis6.assets/wpsF3C8.tmp.jpg" alt="img"> </p>
<p>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，</p>
<p>但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。推荐yes.</p>
<h3 id="rdb的备份"><a href="#rdb的备份" class="headerlink" title="rdb的备份"></a>rdb的备份</h3><p>先通过config get dir  查询rdb文件的目录 </p>
<p>将*.rdb的文件拷贝到别的地方</p>
<p>rdb的恢复</p>
<p>关闭Redis</p>
<p>先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb</p>
<p>启动Redis, 备份数据会直接加载</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高更适合使用</li>
<li>节省磁盘空间</li>
<li>恢复速度快</li>
</ul>
<p><img src="/img/redis6.assets/wpsF3C9.tmp.png" alt="img"> </p>
<h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul>
<li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li>
<li>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>,但是如果数据庞大时还是比较消耗性能。</li>
<li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</li>
</ul>
<h3 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h3><p>动态停止RDB：redis-cli config set save “”#save后给空值，表示禁用保存策略</p>
<h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>以<strong>日志的形式来记录每个写操作（增量保存）</strong>，将Redis执行过的所有<strong>写指令记录下来(读操作不记录)<strong>， 只许</strong>追加文件</strong>但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，<strong>redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</strong></p>
<h3 id="开启AOF"><a href="#开启AOF" class="headerlink" title="开启AOF"></a>开启AOF</h3><p>AOF默认<strong>不开启</strong></p>
<ul>
<li>可以在redis.conf中配置文件名称，默认为 appendonly.aof，AOF文件的保存路径，同RDB的路径一致。在配置文件中配置appendonly <strong>yes</strong> 则开启AOF。</li>
<li>当RDB和AOF同时开启时，<strong>系统默认取AOF的数据</strong>（数据不会存在丢失）</li>
</ul>
<h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><ul>
<li>修改默认的appendonly no，改为yes</li>
<li>如遇到<strong>AOF文件损坏</strong>，通过/usr/local/bin/  redis-check-aof–fix appendonly.aof进行恢复</li>
<li>备份被写坏的AOF文件</li>
<li>恢复：重启redis，然后重新加载</li>
</ul>
<h3 id="配置信息-1"><a href="#配置信息-1" class="headerlink" title="配置信息"></a>配置信息</h3><h4 id="AOF同步频率设置"><a href="#AOF同步频率设置" class="headerlink" title="AOF同步频率设置"></a>AOF同步频率设置</h4><ul>
<li><p>appendfsync always    始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好</p>
</li>
<li><p>appendfsync everysec   每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p>
</li>
<li><p>appendfsync no  redis不主动进行同步，把同步时机交给操作系统。</p>
</li>
</ul>
<h4 id="Rewrite压缩"><a href="#Rewrite压缩" class="headerlink" title="Rewrite压缩"></a>Rewrite压缩</h4><p>如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行<strong>重写</strong>。 </p>
<h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><p><img src="/img/redis6.assets/wps8830.tmp.png" alt="img"> </p>
<ul>
<li>备份机制更<strong>稳健</strong>，丢失数据概率更低。</li>
<li>可读的日志文本，通过操作AOF稳健，可以<strong>处理误操作</strong>。</li>
</ul>
<h3 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h3><ul>
<li>比起RDB<strong>占用更多的磁盘空间</strong>。</li>
<li>恢复<strong>备份速度要慢</strong>。</li>
<li>每次读写都同步的话，有一定的性能压力。</li>
<li>存在个别Bug，造成恢复不能。</li>
</ul>
<h2 id="用谁"><a href="#用谁" class="headerlink" title="用谁"></a>用谁</h2><ul>
<li>官方推荐两个都启用。</li>
<li>如果对数据不敏感，可以选单独用RDB。</li>
<li>不建议单独用 AOF，因为可能会出现Bug。</li>
<li>如果只是做纯内存缓存，可以都不用。</li>
</ul>
<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h2><p>主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，<strong>Master以写为主，Slave以读为主</strong>。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>读写分离，性能扩展</li>
<li>容灾快速恢复</li>
</ul>
<p><img src="/img/redis6.assets/image-20220125113027372.png" alt="image-20220125113027372"></p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>新建redis6379.conf在/myredis文件夹中</p>
<p>配置以下信息</p>
<p><code>include /myredis/redis.conf</code></p>
<p><code>pidfile /var/run/redis_6379.pid</code></p>
<p><code>port 6379</code></p>
<p><code>dbfilename dump6379.rdb</code></p>
<h3 id="新建多个不同端口的配置文件"><a href="#新建多个不同端口的配置文件" class="headerlink" title="新建多个不同端口的配置文件"></a>新建多个不同端口的配置文件</h3><p>并修改端口号</p>
<p><img src="/img/redis6.assets/image-20220125123546200.png" alt="image-20220125123546200"></p>
<h3 id="启动三台服务器"><a href="#启动三台服务器" class="headerlink" title="启动三台服务器"></a>启动三台服务器</h3><p><img src="/img/redis6.assets/image-20220125123647163.png" alt="image-20220125123647163"></p>
<h3 id="查看主从复制的相关信息"><a href="#查看主从复制的相关信息" class="headerlink" title="查看主从复制的相关信息"></a>查看主从复制的相关信息</h3><p><strong>info replication</strong> 在不同端口的redis操作中可以查询主从复制的相关信息（使用redis-cli -p port连接不同的端口） </p>
<p>此时  mster为主机  slaves为从机，以及从机数量和从机的端口号</p>
<h3 id="配从库"><a href="#配从库" class="headerlink" title="配从库"></a>配从库</h3><p>slaveof  <ip><port> 可以将此端口作为port值的从机</p>
<p><img src="/img/redis6.assets/image-20220125124003072.png" alt="image-20220125124003072"></p>
<ul>
<li>此时在主机上进行写操作，从机可以读取数据，但不能在从机上写数据。</li>
<li>主机挂掉后，重启就行，一切如初，但从机需要重新进行slaveof设置他的主机</li>
</ul>
<h2 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h2><p>主机shutdown后，从机会原地待命，不会作为主服务器。主机又回来了后，主机新增记录，从机还能顺利复制。</p>
<p>其中一台从机shutdown后情况如何，重连后会变为master， 需要再次加入主服务器后，才会同步主服务器的内容。</p>
<ul>
<li><strong>全量复制</strong>：当从服务器连接主服务器后，连接到master后会发送一个sync命令，即向主服务器请求同步数据，主服务器收到请求会进行持久化，生成rdb文件，并发送给从服务器，从服务器拿到rdb文件进行读取。</li>
<li><strong>增量复制</strong>：每次主服务器进行写操作后，会又主服务器向从服务器发送数据同步请求。但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li>
</ul>
<p><img src="/img/redis6.assets/image-20220125132151953.png" alt="image-20220125132151953"></p>
<h2 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h2><p><img src="/img/redis6.assets/image-20220125132158511.png" alt="image-20220125132158511"></p>
<p>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。</p>
<p>用 <strong>slaveof  <ip><port></strong></p>
<p>中途变更转向:会清除之前的数据，重新建立拷贝最新的，风险是一旦某个slave宕机，后面的slave都没法备份，主机挂了，从机还是从机，无法写数据了</p>
<h2 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h2><p>当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。</p>
<p>用 <strong>slaveof  no one</strong>  将从机变为主机。</p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p><strong>反客为主的自动版</strong>，能够后台<strong>监控</strong>主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p>
<p><img src="/img/redis6.assets/image-20220125131645854.png" alt="image-20220125131645854"></p>
<h3 id="配置哨兵"><a href="#配置哨兵" class="headerlink" title="配置哨兵"></a>配置哨兵</h3><p><strong>sentinel monitor mymaster 127.0.0.1 6379 1</strong></p>
<p>其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。 </p>
<h3 id="启动哨兵"><a href="#启动哨兵" class="headerlink" title="启动哨兵"></a>启动哨兵</h3><p>/usr/local/bin</p>
<p>redis做压测可以用自带的redis-benchmark工具</p>
<p>执行<strong>redis-sentinel  /myredis/sentinel.conf</strong> </p>
<p><img src="/img/redis6.assets/image-20220125131744673.png" alt="image-20220125131744673"></p>
<h3 id="怎么选择主机"><a href="#怎么选择主机" class="headerlink" title="怎么选择主机"></a>怎么选择主机</h3><p>根据优先级别：<strong>slave-priority</strong>  原主机重启后会变为从机。</p>
<h3 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h3><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>
<h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><p><img src="/img/redis6.assets/image-20220125131950756.png" alt="image-20220125131950756"></p>
<p>优先级在redis.conf中默认：slave-priority 100，值越小优先级越高</p>
<p>偏移量是指获得原主机数据最全的（与原机数据相似度最高）</p>
<p>每个redis实例启动后都会随机生成一个40位的runid</p>
<h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>容量不够，redis如何进行扩容？，并发根据优先级别：slave-priority </p>
<p>原主机重启后会变为从机。写操作， redis如何分摊？</p>
<p>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p>
<p>之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。</p>
<h2 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h2><p>Redis 集群实现了对Redis<strong>的水平扩容</strong>，即启动N个redis节点，将<strong>整个数据库分布存储在这N个节点中</strong>，每个节点存储总数据的1/N。</p>
<p>Redis 集群通过分区（partition）来提供一定程度的<strong>可用性</strong>（availability）： <strong>即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</strong></p>
<h2 id="删除持久化数据"><a href="#删除持久化数据" class="headerlink" title="删除持久化数据"></a>删除持久化数据</h2><p>将rdb,aof文件都删除掉。</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>实现6个实例，6379,6380,6381,6389,6390,6391</p>
<h3 id="配置基本信息"><a href="#配置基本信息" class="headerlink" title="配置基本信息"></a>配置基本信息</h3><p>开启daemonize yes，Pid文件名字，指定端口，Log文件名字，Dump.rdb名字，Appendonly 关掉或者换名字</p>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>cluster-enabled yes  打开集群模式</p>
<p>cluster-config-file nodes-6379.conf 设定节点配置文件名</p>
<p>cluster-node-timeout 15000  设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</p>
<ul>
<li>详细信息</li>
</ul>
<p><code>include /myredis/redis.conf</code><br><code>pidfile &quot;/var/run/redis_6379.pid&quot;</code><br><code>dbfilename &quot;dump6379.rdb&quot;</code><br><code>port 6379</code><br><code>cluster enabled yes</code><br><code>cluster-config-file nodes-6379.conf</code><br><code>cluster-node-timeout 15000</code></p>
<h3 id="拷贝多个文件"><a href="#拷贝多个文件" class="headerlink" title="拷贝多个文件"></a>拷贝多个文件</h3><p><img src="/img/redis6.assets/image-20220124201334239.png" alt="image-20220124201334239"></p>
<p>使用 ：%s/6379/6380  命令修改端口号</p>
<h3 id="启动6个redis服务"><a href="#启动6个redis服务" class="headerlink" title="启动6个redis服务"></a>启动6个redis服务</h3><p><img src="/img/redis6.assets/image-20220124201932763.png" alt="image-20220124201932763"></p>
<h3 id="将6个节点合成一个集群"><a href="#将6个节点合成一个集群" class="headerlink" title="将6个节点合成一个集群"></a>将6个节点合成一个集群</h3><p>组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。</p>
<p><img src="/img/redis6.assets/image-20220124202637315.png" alt="image-20220124202637315"></p>
<h3 id="合体"><a href="#合体" class="headerlink" title="合体"></a>合体</h3><p>进入到  <strong>cd  /opt/redis-6.2.1/src</strong>  目录执行（需要使用ruby环境）</p>
<p><code>redis-cli --cluster create --cluster-replicas 1 192.168.241.130:6379 192.168.241.130:6380 192.168.241.130:6381 192.168.241.130:6382 192.168.241.130:6383 192.168.241.130:6384</code></p>
<p><img src="/img/redis6.assets/image-20220124203127906.png" alt="image-20220124203127906"></p>
<p>此处不要用127.0.0.1， <strong>请用真实IP地址</strong></p>
<p>–replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。</p>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><ul>
<li>普通方式登录：可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。</li>
<li>-c 采用集群策略连接，设置数据会自动切换到相应的写主机</li>
</ul>
<p><img src="/img/redis6.assets/image-20220124204309813.png" alt="image-20220124204309813"></p>
<h2 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h2><p>通过<strong>cluster nodes</strong>命令查看集群信息</p>
<p><img src="/img/redis6.assets/image-20220124211147941.png" alt="image-20220124211147941"></p>
<h3 id="redis-cluster-如何分配着六个节点"><a href="#redis-cluster-如何分配着六个节点" class="headerlink" title="redis cluster 如何分配着六个节点"></a>redis cluster 如何分配着六个节点</h3><p>一个集群<strong>至少要有三个主节点</strong>。选项 <strong>–cluster-replicas 1</strong> 表示我们希望<strong>为集群中的每个主节点创建一个从节点</strong>。</p>
<p>分配原则尽量保证每个主数据库运行<strong>在不同的IP地址</strong>，每个<strong>从库和主库不在一个IP地址上</strong>。</p>
<h2 id="Slots"><a href="#Slots" class="headerlink" title="Slots"></a>Slots</h2><ul>
<li><p>一个 Redis 集群包含 <strong>16384</strong> 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个，集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p>
</li>
<li><p>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：</p>
<p>节点 A 负责处理 0 号至 5460 号插槽。</p>
<p>节点 B 负责处理 5461 号至 10922 号插槽。</p>
<p>节点 C 负责处理 10923 号至 16383 号插槽。</p>
</li>
</ul>
<h3 id="在集群中录入值"><a href="#在集群中录入值" class="headerlink" title="在集群中录入值"></a>在集群中录入值</h3><p>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。</p>
<p>redis-cli客户端提供了 <strong>–c</strong> 参数<strong>实现自动重定向</strong>。</p>
<p>如 redis-cli  -c –p 6379 登入后，再录入、查询键值对可以自动重定向。</p>
<ul>
<li><p>录入多个key时：不在一个slot下的键值，是不能使用mget,mset等多键操作。可以通过**{}来定义组的概念，**从而使key中{}内相同内容的键值对放到一个slot中去。</p>
<p><img src="/img/redis6.assets/image-20220124211923794.png" alt="image-20220124211923794"></p>
<p>因为计算插槽值时时通过key来计算，所以使用{}定义在<strong>同一个key</strong>则可以计算插槽。</p>
</li>
</ul>
<h3 id="查询集群中的值"><a href="#查询集群中的值" class="headerlink" title="查询集群中的值"></a>查询集群中的值</h3><p>CLUSTER GETKEYSINSLOT <slot><count> 返回 count 个 slot 槽中的键。</p>
<p><img src="/img/redis6.assets/image-20220124212609811.png" alt="image-20220124212609811"></p>
<h2 id="故障恢复-1"><a href="#故障恢复-1" class="headerlink" title="故障恢复"></a>故障恢复</h2><p>主服务器挂掉后，<strong>从节点会自动生为主节点</strong>（注意15秒超时）,当主节点恢复后，会变为<strong>从节点</strong>。</p>
<h4 id="如果所有某一段插槽的主从节点都宕掉"><a href="#如果所有某一段插槽的主从节点都宕掉" class="headerlink" title="如果所有某一段插槽的主从节点都宕掉"></a>如果所有某一段插槽的主从节点都宕掉</h4><p>redis.conf中的参数  <strong>cluster-require-full-coverage</strong></p>
<ul>
<li>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为<strong>yes</strong> ，那么 ，<strong>整个集群都挂掉</strong></li>
<li>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为<strong>no</strong> ，那么，<strong>该插槽数据全都不能使用，也无法存储</strong>。</li>
</ul>
<h2 id="集群的好处"><a href="#集群的好处" class="headerlink" title="集群的好处"></a>集群的好处</h2><ul>
<li>实现扩容</li>
<li>分摊压力</li>
<li>无中心配置相对简单</li>
</ul>
<h2 id="集群的不足"><a href="#集群的不足" class="headerlink" title="集群的不足"></a>集群的不足</h2><ul>
<li>多键操作是不被支持的 </li>
<li>多键的Redis事务是不被支持的。lua脚本不被支持</li>
<li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</li>
</ul>
<h1 id="应用问题解决"><a href="#应用问题解决" class="headerlink" title="应用问题解决"></a>应用问题解决</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>key对应的数据<strong>在数据源并不存在</strong>，<strong>每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源</strong>。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p>
<p><img src="/img/redis6.assets/image-20220125101915689.png" alt="image-20220125101915689"></p>
<p>解决方案</p>
<p>（1） <strong>对空值缓存：</strong>如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</p>
<p>（2） <strong>设置可访问的名单（白名单）：</strong></p>
<p>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p>
<p>（3） <strong>采用布隆过滤器</strong>：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。</p>
<p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)</p>
<p>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</p>
<p>（4） <strong>进行实时监控：</strong>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</p>
<h2 id="缓存穿透-1"><a href="#缓存穿透-1" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>单个</strong>key<strong>对应的数据存在，但在redis中过期</strong>，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p><img src="/img/redis6.assets/image-20220125102227874.png" alt="image-20220125102227874"></p>
<p>解决方案</p>
<p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p>
<p><strong>（1）预先设置热门数据：</strong>在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</p>
<p><strong>（2）实时调整：</strong>现场监控哪些数据热门，实时调整key的过期时长</p>
<p><strong>（3）使用锁：</strong></p>
<ul>
<li> 就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</li>
<li>先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）</li>
<li>当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</li>
<li>当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>多个</strong>key<strong>对应的数据存在，但在redis中过期</strong>，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p><strong>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key</strong></p>
<p><img src="/img/redis6.assets/image-20220125102654418.png" alt="image-20220125102654418"></p>
<p>解决方案</p>
<p>（1） <strong>构建多级缓存架构：</strong>nginx缓存 + redis缓存 +其他缓存（ehcache等）</p>
<p>（2） <strong>使用锁或队列</strong>：用<strong>加锁或者队列</strong>的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。<strong>不适用高并发情况</strong></p>
<p>（3）<strong>设置过期标志更新缓存</strong>：记录缓存数据是否过期（<strong>设置提前量</strong>），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p>
<p>（4)  <strong>将缓存失效时间分散开：</strong>如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的<strong>重复率</strong>就会降低，就很难引发集体失效的事件。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p>
<h3 id="Redis操作"><a href="#Redis操作" class="headerlink" title="Redis操作"></a>Redis操作</h3><ul>
<li>使用set <key>  <value>  nx ex <time> 可以实现分布式锁，在设置时直接设置过期时间</li>
<li>直接使用setnx， <key> <value> 不设置时间会造成锁无法释放，也可以empire设置过期时间</li>
<li>del <key> 可以直接释放锁，就可以再次设置</li>
<li>具体操作:<ol>
<li>多个客户端同时获取锁（setnx）</li>
<li>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</li>
<li>其他客户端等待重试</li>
</ol>
</li>
</ul>
<h3 id="UUID防止误删"><a href="#UUID防止误删" class="headerlink" title="UUID防止误删"></a>UUID防止误删</h3><p>setnx设置锁时，设置一个唯一的值（UUID），释放前比较<strong>是否相等</strong>，从而将自己对应UUID的锁删除。</p>
<p><img src="/img/redis6.assets/image-20220125112210314.png" alt="image-20220125112210314"></p>
<h3 id="LUA保证删除原子性"><a href="#LUA保证删除原子性" class="headerlink" title="LUA保证删除原子性"></a>LUA保证删除原子性</h3><p>在A获取锁操作后，判断UUID相等后，准备执行删除，而此时服务器卡顿，还未成功执行删除，而锁设置的时间自动过期，此时B获得锁进行操作，而A现在却将锁释放，造成B还未操作完锁就被释放。这是使用UUID可能会造成没有原子性。</p>
<p>使用LUA脚本可以解决。</p>
<h3 id="分布式锁的使用注意"><a href="#分布式锁的使用注意" class="headerlink" title="分布式锁的使用注意"></a>分布式锁的使用注意</h3><p>为了确保分布式锁可用，我们至少要确保锁的实现同时<strong>满足以下四个条件</strong>：</p>
<ul>
<li>互斥性。在任意时刻，只有一个客户端能持有锁。</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li>
<li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li>
<li>加锁和解锁必须具有原子性。</li>
</ul>
<h1 id="Redis6新功能"><a href="#Redis6新功能" class="headerlink" title="Redis6新功能"></a>Redis6新功能</h1><h2 id="ACL（参考官网）"><a href="#ACL（参考官网）" class="headerlink" title="ACL（参考官网）"></a>ACL（<a target="_blank" rel="noopener" href="https://redis.io/topics/acl">参考官网</a>）</h2><h3 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h3><p>edis ACL是Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。</p>
<p>在Redis 5版本之前，Redis 安全规则<strong>只有密码控制</strong> 还有通过<strong>rename</strong> 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制 ：</p>
<p>（1）接入权限:用户名和密码 </p>
<p>（2）可以执行的命令 </p>
<p>（3）可以操作的 KEY</p>
<p><img src="/img/redis6.assets/image-20220125135021831.png" alt="image-20220125135021831"></p>
<h3 id="使用acl-cat命令"><a href="#使用acl-cat命令" class="headerlink" title="使用acl cat命令"></a>使用acl cat命令</h3><ul>
<li><p>查看添加权限指令类别</p>
<p><img src="/img/redis6.assets/image-20220125135315536.png" alt="image-20220125135315536"></p>
</li>
<li><p>加参数类型名可以查看类型下具体命令</p>
<p><img src="/img/redis6.assets/image-20220125135353795.png" alt="image-20220125135353795"></p>
</li>
<li><p>使用acl whoami命令查看当前用户</p>
</li>
<li><p>使用aclsetuser命令创建和编辑用户ACL</p>
</li>
</ul>
<h3 id="ACL规则"><a href="#ACL规则" class="headerlink" title="ACL规则"></a>ACL规则</h3><ul>
<li>下面是有效ACL规则的列表。某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。</li>
</ul>
<p><img src="/img/redis6.assets/image-20220125140001251.png" alt="image-20220125140001251"></p>
<ul>
<li>通过命令创建新用户默认权限</li>
</ul>
<p>acl setuser user1</p>
<p><img src="/img/redis6.assets/wps53F2.tmp.jpg" alt="img"> </p>
<p>在上面的示例中，我根本没有指定任何规则。如果用户不存在，这将使用just created的默认属性来创建用户。如果用户已经存在，则上面的命令将不执行任何操作。</p>
<ul>
<li>设置有用户名、密码、ACL权限、并启用的用户</li>
</ul>
<p>acl setuser user2 on &gt;password ~cached:* +get</p>
<p><img src="/img/redis6.assets/wps53F3.tmp.jpg" alt="img"> </p>
<ul>
<li> 切换用户，验证权限</li>
</ul>
<p><img src="/img/redis6.assets/wps53F4.tmp.jpg" alt="img"> </p>
<h2 id="IO多线程"><a href="#IO多线程" class="headerlink" title="IO多线程"></a>IO多线程</h2><h3 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h3><p>IO多线程其实<strong>指客户端交互部分的网络IO交互处理模块多线程</strong>，而非执行命令多线程。Redis6<strong>执行命令依然是单线程</strong>。</p>
<h3 id="原理架构"><a href="#原理架构" class="headerlink" title="原理架构"></a>原理架构</h3><p>Redis 6 加入多线程,但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。整体的设计大体如下:</p>
<p><img src="/img/redis6.assets/wps53F5.tmp.jpg" alt="img"> </p>
<h3 id="开启IO多线程"><a href="#开启IO多线程" class="headerlink" title="开启IO多线程"></a>开启IO多线程</h3><p>另外，多线程IO默认也是不开启的，需要再配置文件中配置</p>
<p>io-threads-do-reads  yes </p>
<p>io-threads 4</p>
<p>工具支持 Cluster</p>
<p>之前老版Redis想要搭集群需要单独安装ruby环境，Redis 5 将 redis-trib.rb 的功能集成到 redis-cli 。另外官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测。</p>
<p><img src="/img/redis6.assets/wps5406.tmp.jpg" alt="img"> </p>
<h2 id="Redis新功能持续关注"><a href="#Redis新功能持续关注" class="headerlink" title="Redis新功能持续关注"></a>Redis新功能持续关注</h2><p>Redis6新功能还有：</p>
<p>1、RESP3新的 Redis 通信协议：优化服务端与客户端之间通信</p>
<p>2、Client side caching客户端缓存：基于 RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。</p>
<p>3、Proxy集群代理模式：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变 Cluster 的功能限制，不支持的命令还是不会支持，比如跨 slot 的多Key操作。</p>
<p>4、Modules API</p>
<p>Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放的平台。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Redis/">Redis</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Redis/">Redis</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/02/12/Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Nacos配置中心</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/02/01/%E5%B0%9A%E7%AD%B9%E7%BD%91/">
                        <span class="hidden-mobile">尚筹网</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>





  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
